{"meta":{"title":"今天DJ无敌了吗","subtitle":"我又无敌了","description":"你们是谁？","author":"GM-D","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"查找和删除子物体方法","date":"2019-08-14T14:37:53.777Z","updated":"2019-08-14T15:48:30.755Z","comments":true,"path":"2019/08/14/查找和删除子物体方法/","link":"","permalink":"http://yoursite.com/2019/08/14/查找和删除子物体方法/","excerpt":"","text":"查找子物体总个数（包括孙子（即子物体的子物体），曾孙（子物体的子物体的子物体)) 思路： Transform.GetChild(index)是获取当前物体下的第index个物体，返回值为Transform类型。Transform.childCount是获取当前物体下有多少个同级别的子物体个数（即不包括子物体的子物体）。有了这2个方法后，可以写一个方法来获取同级的个数。 1234private void FindChild(Transform tf,ref int count)&#123; count=tf.childCount;&#125; 然后在Start()方法里调用这个方法就能获取当前同级下的子物体个数了。现在的问题在于：如何得到子物体的子物体。把FindChild方法给子物体不就能得到子物体了嘛。 思路不就来了嘛，上面介绍了刚刚介绍了Transform.GetChild(index)方法,传入一个index得到第index个子物体，那么把第index个子物体传入FindChild()方法不就能找到它的子物体了嘛。有的人又问了：这只能得到第index个物体啊，我如果想全都要呢？全都要就用for循环啊，tf.childCount不就是全部子物体吗? 12345678private void FindChild(Transform tf.ref int count)&#123; count+=tf.childCount; for(int i=0;i&lt;tf.childCount;i++) &#123; FindChild(tf.GetChild(i),ref count); &#125;&#125; 注意上面count是+=tf.childCount,因为count是累加的。 删除子物体 思路: 当你Destroy一个物体时，它的子物体也会被顺带删除，所以Destroy当前物体的子物体就行了。 1234567private void DestroyChild(transform tf)&#123; for(int i=0;i&lt;tf.childCount;i++) &#123; Destroy(tf.GetChild(i).gameoject); &#125;&#125; 如果硬是要你用DestroyImmidiate（）这种方法，就有点烦人了。DestroyImmidiate()是立即执行的，而在Start()方法里是每帧执行，这样导致了childCount一直在变。因此有2种方法。因为childCount一直在变，所以从子物体的最后一个开始删，就算childCount一直在变，他的最后一个也不会变。 第一种方法1234567private void DestroyA(Transform tf)&#123; for(int i=tf.childCount-1;i&gt;=0;i--) &#123; DestroyImmediate(tf.GetChild(i).gameObject); &#125;&#125; 第二种方法 一直删除第一个，直到他的childCount为0，就跳出. 1234567891011private void DestroyB(transform tf)&#123; while(true) &#123; DestroyImmediate(tf.GetChild(0).gameObject); if(tf.childCount==0) &#123; break; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"今天我又变强了！","slug":"今天我又变强了","date":"2019-08-10T19:19:52.000Z","updated":"2019-08-12T19:11:13.754Z","comments":true,"path":"2019/08/11/今天我又变强了/","link":"","permalink":"http://yoursite.com/2019/08/11/今天我又变强了/","excerpt":"","text":"如题所示今天我把二连跳弄出来了，思路很简单，想到就直接打出来了。还通宵弄了个vps，这下可以不用忍受辣鸡翻墙软件的龟速了。明天继续变强! 二连跳思路： 最开始的思路是在Input.GetKeyDown(KeyCode.Space).里用一个参数控制它只能跳两次。首先想到的是用int类型定义一个变量JumpCount,默认为0次,当按下空格键时，JumpCount自增一次。然后当JumpCount==2时，return这个按下空格键操作。 限制跳跃次数后，紧接着要把JumpCount清0。此时你脑海里第一个想法肯定是碰到地面清0，这时肯定是在检查碰撞方法中完成。 1234private void OnCollisionEnter2D(Collision2D collision) &#123; JumpCount = 0; &#125; 但是问题又来了，当你碰到除了地面的东西，比如墙壁，比如道具盒子，比如你碰到任何除了地面的物体时，你都能二段跳，这与我们的想法差强人意（成语鬼才是我），这时，解决这种问题的方法就是，设tag。代码改成： 1234567private void OnCollisionEnter2D(Collision2D collision) &#123; if (collision.gameObject.tag==\"ground\") &#123; JumpCount = 0; &#125; ｝ 噔噔噔噔，一个简单的二连跳做出来了。但是问题又又又来了：比如旁边有个坑，这样我岂不是可以在坑的墙边来回二段跳爬上来？ ！举个栗子 那你给坑边墙的tag改成其它不就行了嘛。你可真是个臭弟弟呢。","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2019-08-09T16:50:14.000Z","updated":"2019-08-10T05:16:51.711Z","comments":true,"path":"2019/08/10/我的第一篇博客/","link":"","permalink":"http://yoursite.com/2019/08/10/我的第一篇博客/","excerpt":"","text":"我成功啦！！我成功啦！！ 这是我自己弄出来的博客!这是我在b站看codeSheep视频弄出来的博客感谢codeSheep! 接下来我会在这个博客中记录我在学习或工作中遇到的难题困难和解决思路。当然如果有一些小技巧我也会记录下来。 冲鸭！","categories":[],"tags":[]}]}